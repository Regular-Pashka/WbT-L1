package main

import (
	"fmt"
	"unsafe"
)
/* 
	12. Что выведет данная программа и почему?
*/

// func main() {
// 	n := 0
// 	if true {
// 		n := 1
// 		n++
// 		fmt.Println(n)
// 	}
// 	fmt.Println(n)
// }


/* 
	ВЫВОД ПО ЗАДАЧЕ:
	В языке Go любые блоки кода, ограниченные фигурными скобками {}, создают свою локальную область видимости.
*/ 


/* 13. Что выведет данная программа и почему? */

func someAction(v []int8, b int8) {
	v[0] = 100
	v = append(v, b)
	fmt.Printf("%p\n", v)
	fmt.Println(v)
}
	
func main() {
	var a = make([]int8, 5, 10)
	for i := 0; i < 5; i++ {
		a[i] = int8(i + 1)
	}
	someAction(a, 6)
	fmt.Printf("%p\n", a)
	p := &a[0]	
	for i := 0; i < len(a) + 1; i++ {
        // Вычисляем адрес i-го элемента
        addr := uintptr(unsafe.Pointer(p)) + uintptr(i)*unsafe.Sizeof(a[0])
        value := *(*int8)(unsafe.Pointer(addr)) // Преобразуем обратно в указатель на int и разыменовываем
        fmt.Printf("Value at index %d: %d\n", i, value)
    }
}

/* 
	ВЫВОД :
	append в этом случае вернет структуру с тремя полями: тем же указателем, тем же капасити но другим length равным шести. Он действительно добавит по мейновскому указателю шестерку, но так как в мейновском слайсе у нас структура с длиной 5, а не 6, то бишь отличный экземпляр структуры от того, что вернул append в функции, мы эту шестерку можем увидеть только с помощью адресной арифметики(пакета unsafe)
*/